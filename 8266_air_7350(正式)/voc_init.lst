C51 COMPILER V9.50a   VOC_INIT                                                             05/10/2018 15:57:52 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE VOC_INIT
OBJECT MODULE PLACED IN .\hexfirmware\voc_init.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE app\voc_init.c BROWSE DEBUG OBJECTEXTEND PRINT(.\voc_init.lst) TABS(2) OBJE
                    -CT(.\hexfirmware\voc_init.obj)

line level    source

   1          #include "include\voc_init.h"
   2          
   3          
   4          
   5          extern unsigned char test_staus;
   6          /*************************************************************
   7          ËµÃ÷£º
   8          TEST==TEST_PWM
   9          1¡¢P00,P01,P02£¬P25£¬P26£¬P27ÎªPWMÊä³ö£¬FsysÆµÂÊ£¬ÖÜÆÚÎª99+1=100£»PWMDTY0Îª50£¬PWMDTY1Îª25£¬PWMDTY2Îª10£¬P
             -WMDTY3Îª50£¬PWMDTY4Îª25£¬PWMDTY5Îª10£»
  10          2¡¢PWMÆµÂÊ¼ÆËã¹«Ê½f=PWMÊ±ÖÓÔ´/£¨PWMPRD+1£©£»Õ¼¿Õ±È=PWMDTYx/£¨PWMPRD+1£©;
  11          ***************************************************************/
  12          
  13          void PWMwork(void)
  14          {
  15   1      /*
  16   1        //7320Ê¹ÓÃ
  17   1        PWMCON = 0X30;      //PWM1\PWM2Êä³öµ½I/O£¬FsysÆµÂÊ£»PWM0\²»Êä³ö
  18   1        PWMCFG = 0x06;      //²»·´Ïò£¬P00,P01,P02Êä³ö pwm1 Êä³öµ½2.6 PWM2 Êä³öµ½2.7
  19   1        PWMPRD = 99;      //PWMÖÜÆÚ=(99+1)       
  20   1       // PWMDTY0 = 50;     //PWM0µÄDuty = 50/100  =1/2
  21   1        PWMDTY1 = 100;//25;     //PWM1µÄDuty = 25/100  =1/4 
  22   1        PWMDTY2 = 100;//10;     //PWM2µÄDuty = 10/100  =1/10
  23   1        //PWMDTYA = 0x15;     //PWM2/PWM1/PWM0 dutyÎ¢µ÷£¬ÎªPWMDTYÉè¶¨Öµ¼Ó1
  24   1        PWMCON |= 0x80;     //¿ªÊ¼PWM¹¤×÷
  25   1        */
  26   1        
  27   1      
  28   1        //7350Ê¹ÓÃ
  29   1        PWMCON  = 0X00;   //PWM0\PWM1\PWM2²»Êä³öµ½I/O£¬Ê§ÄÜ£¬Ñ¡ÔñFsysÆµÂÊ£»
  30   1        PWMCFG0 = 0x06;   //PWM0\PWM1\PWM2²»·´Ïò£¬PWM4\PWM5Êä³öµ½I/O PWM3\²»Ê¹ÄÜ
  31   1        PWMCFG1 = 0x00;   //PWM3\PWM4\PWM5²»·´Ïò
  32   1        PWMPRD  = 199;      //PWMÖÜÆÚ=(99+1)       
  33   1        PWMDTY4 = 200;      //PWM4µÄDuty = 25/100  =1/4
  34   1        PWMDTY5 = 200;      //PWM5µÄDuty = 10/100  =1/10
  35   1        PWMCON |= 0x80;   //Æô¶¯PWM¹¤×÷
  36   1        
  37   1      }
  38          
  39          /*************************************************************
  40          ËµÃ÷£º
  41          ¿ØÖÆLED ÁÁ¶È PWM1¡¢2 ÊÇÓÃÔÚ7320ÉÏ  ÈôÐèÓÃ7250 ÔòÊÇPWM4¡¢5
  42          ***************************************************************/
  43          
  44          void LED_Ctrl(unsigned char duty,unsigned char no)
  45          {
  46   1        switch(no)
  47   1        {
  48   2          case GREEN: PWMDTY4 = duty;
  49   2          
  50   2          break;
  51   2          case BLUE:  PWMDTY5 = duty;
  52   2          
  53   2          break;
C51 COMPILER V9.50a   VOC_INIT                                                             05/10/2018 15:57:52 PAGE 2   

  54   2          case RED:if(duty == 0)P1 = 0x00;//¿ªµÆ
  55   2                    else P1 = 0x04;//¹ØµÆ
  56   2          
  57   2          break;
  58   2        }
  59   1      }
  60          /*************************************************************
  61          ËµÃ÷£º
  62          TEST==TEST_ADC
  63          1¡¢ADCworkµÄ²ÎÊý°üÀ¨£¨ÊäÈëÍ¨µÀAIN0~AIN9»ò²âÁ¿1/4VDDµçÑ¹VDD_DIV4£¬²ÉÑùËÙ¶ÈÌî0Îª2M£¬Ìî1Îª333K£©
  64          0~50 ±íÊ¾ 0~5.0V
  65          ***************************************************************/
  66          
  67          
  68          
  69          unsigned long ADCwork(unsigned char Channel,unsigned char Clk)
  70          {
  71   1        unsigned int SetAdcIo; 
  72   1        unsigned long AdcValue;
  73   1        ADCCON   = ADCCON & (~0X1F) | Channel | (Clk<<5) ;  //ÅäÖÃADCÊäÈëÍ¨µÀºÍ²É¼¯Ê±ÖÓÆµÂÊ
  74   1        ADCCON|=0x80;                  //´ò¿ªADCÄ£¿éµçÔ´
  75   1        SetAdcIo = (0x0001 << Channel) & (~0Xfe00) ;   
  76   1        ADCCFG0  = (unsigned char)SetAdcIo;        //ÅäÖÃÎªADCÊäÈë
  77   1        ADCCFG1  = (unsigned char)(SetAdcIo >> 8);
  78   1      
  79   1        ADCCON|=0x40;              //Æô¶¯ADC²É¼¯
  80   1        while(!(ADCCON&0x10));               //µÈ´ý ADC×ª»»Íê³É;
  81   1        AdcValue=(ADCVH<<4)+(ADCVL>>4);
  82   1        
  83   1        return (AdcValue * 50/4095);
  84   1      }
  85          
  86          
  87          /*************************************************************
  88          ËµÃ÷£º
  89          TEST==TEST_TIMER
  90          1¡¢¶¨Ê±Æ÷ÎªÏòÉÏÒç³ö·½Ê½£¬T¶¨Ê±¼ÆËã¹«Ê½=TxÊ±ÖÓÔ´*£¨ÂúÁ¿³ÌÖµ+1-Ô¤×°ÔØÖµ£©
  91          ***************************************************************/
  92          
  93          #define   tst0    P00
  94          
  95          void Timerwork(void)
  96          {
  97   1        TMCON=0x07;             //------111 ;Timer0¡¢Tiemr1ºÍTiemr2Ñ¡ÔñÊ±ÖÓFsys
  98   1        TMOD=0x31;              //0011 0001  ;Timer0¹¤×÷·½Ê½1 Timer1 ²»¹¤×÷  16Î»¼ÆÊýÆ÷
  99   1      //T0ÉèÖÃ  
 100   1        // 0x4480
 101   1        TH0= (65536 - 48000)/256;           //Èç¹ûÖ÷ÆµÎª24MºÍÊ±ÖÓFsysÔò24M*48000= 2ms;   
 102   1        TL0= (65536 - 48000)%256;             //TH0= 0x44; TL0 = 0x80; Ò²¿ÉÒÔÕâÑùÐ´
 103   1        TR0=0;          
 104   1        ET0=1;                //Timer0Ê¹ÄÜ
 105   1        TR0=1;                //Æô¶¯Timer0
 106   1        
 107   1        EA=1;
 108   1      }
 109          
 110          void timer0()interrupt 1        //Timer0ÏòÁ¿ºÅ 1  2ms½øÈëÒ»´ÎÖÐ¶Ï
 111          {
 112   1        WDTCON |= 0x10;       //Çå¿´ÃÅ¹·  
 113   1        
 114   1        TH0= (65536 - 48000)/256;           //ÔÙ´Î×°Èë³õÖµ 
 115   1        TL0= (65536 - 48000)%256;   
C51 COMPILER V9.50a   VOC_INIT                                                             05/10/2018 15:57:52 PAGE 3   

 116   1        if(++Cnt_10ms >= 5 && (flag_10ms == 0))
 117   1        {
 118   2          Cnt_10ms = 0;
 119   2          flag_10ms = 1;
 120   2        }
 121   1        tst0 =~tst0;
 122   1      }
 123          
 124          
 125          
 126          /*************************************************************
 127          ËµÃ÷£º
 128          
 129          1¡¢key¼ì²â
 130          ***************************************************************/
 131          void KeyPress(void)
 132          {
 133   1        static unsigned int Cnt_key = 0;
 134   1        static unsigned int Cnt_KeyUP = 0;
 135   1        static unsigned char flag_keyup = 0;
 136   1        //p2.1
 137   1        if((P2 & 0x02) == 0x00)//°´¼ü°´ÏÂ
 138   1        {
 139   2          Cnt_key ++;
 140   2        }
 141   1        else
 142   1        {
 143   2          if(Cnt_key >4 && Cnt_key < 50)
 144   2          {
 145   3            flag_keyup ++;
 146   3          }
 147   2          
 148   2          if(flag_keyup)
 149   2          {
 150   3            Cnt_KeyUP ++;
 151   3          }
 152   2          if(flag_keyup == 3 && Cnt_KeyUP > 50)
 153   2          {//Èç¹ûÁ¬°´Èý´Î
 154   3              Cnt_KeyUP = 0;
 155   3              flag_keyup = 0;
 156   3              //ÃðµÆ
 157   3              LED_Ctrl(200,GREEN);
 158   3              LED_Ctrl(200,RED);
 159   3              LED_Ctrl(200,BLUE);
 160   3              ProgramPara.Cnt_Minite = 0;
 161   3              ProgramPara.SubMode = 0x03; //Mode_Test
 162   3              //Mode = Mode_Test;
 163   3      
 164   3          }
 165   2          if(flag_keyup != 1 && flag_keyup != 3 && Cnt_KeyUP > 50)
 166   2          {
 167   3              flag_keyup = 0;
 168   3              Cnt_KeyUP = 0;
 169   3          }
 170   2          Cnt_key = 0;
 171   2        }
 172   1      }
 173          
 174          /*************************************************************
 175          ËµÃ÷£º
 176          1¡¢ÄÚ²¿ÓÐ128BYTEµÄEEPROM¿ÉÒÔ´æÊý¾Ý¡£
 177          ***************************************************************/
C51 COMPILER V9.50a   VOC_INIT                                                             05/10/2018 15:57:52 PAGE 4   

 178          
 179          
 180          unsigned char ReadData;
 181          
 182          void EepromWrite(unsigned char Data,unsigned int Addr,unsigned char eHoldtimer)   //DataÎªÐ´ÈëÊý¾Ý£¬AddrÎªÐ
             -´ÈëµØÖ·£¬eHoldtimerÎªÐ´ÈëÊ±¼ä£»
 183          {
 184   1        IAPDAT = Data;                              //ÅäÖÃÐ´ÈëÊý¾Ý
 185   1        IAPADH = (unsigned char)((Addr >> 8));                   //ÅäÖÃÐ´ÈëµØÖ·
 186   1        IAPADL = (unsigned char)Addr;
 187   1        EA=0;                                  //ÏÈ¹Ø×ÜÖÐ¶Ï
 188   1        IAPADE = MOVC_EEPROM;                          //MOVCÖ¸ÏòEEPROM
 189   1        IAPKEY = 240 ;
 190   1        IAPCTL = eHoldtimer;                           //Æô¶¯Ð´Èë
 191   1          _nop_();                                 //ÖÁÉÙ²åÈë4¸ö_nop_();ÒÔÉÏ
 192   1          _nop_();
 193   1          _nop_();
 194   1          _nop_();
 195   1          _nop_();
 196   1        IAPADE = MOVC_ROM;                             //MOVCÖ¸ÏòROM
 197   1        EA=1;                                    //¿ª×ÜÖÐ¶Ï
 198   1      }
 199          
 200          unsigned char EepromRead(unsigned char Addr)
 201          {
 202   1        unsigned char code *IapAddr=0x00;               //ÅäÖÃ¶ÁµÄ³õÊ¼Ö¸Õë
 203   1        unsigned char Temp;
 204   1        EA=0;                             //ÏÈ¹Ø×ÜÖÐ¶Ï
 205   1        IAPADE = MOVC_EEPROM;                     //MOVCÖ¸ÏòEEPROM
 206   1        Temp = *(IapAddr+Addr);                     //¶ÁAddrµØÖ·µÄÊý¾Ý
 207   1        IAPADE = MOVC_ROM;                        //MOVCÖ¸ÏòROM
 208   1        EA=1;                             //¿ª×ÜÖÐ¶Ï
 209   1        return Temp;
 210   1      }
 211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    406    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
